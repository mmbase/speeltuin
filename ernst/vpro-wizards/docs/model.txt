Overview data model wizard servlet

Introduction

A request to the wizard servlet consists of the following steps. The classes are designed in such a way that each step is captured with an interface and different implementations can be plugged in. this way the system can be modified and expanded in a structured way.
There are two distinct mechanisms that make up the system. The WizardController handles the databinding execution of the actions, and CacheInterceptor that is a Spring Interceptor implementation, and that processes the cache flush hints that are generated by the actions in a plugable way. This docuement describes the Wizard Controller, and the cache flush architecture.

the WizardController
--------------------

This is the controller class that handles all the request. The template pattern has been used to isolate every step of the way, while protecting the work flow. the steps are:
    1 - acquire cloud (transaction)
    2 - data binding through the command object
    3 - execute the actions (as long as there are no errors
    4 - when there are errors: rollback
    5 - resolve the return view.

1 acquire cloud
    The CloudFactory interface implementation is used to get a cloud (transaction) instance. This interface uses another interface to resolve credentials used to obtain the cloud. There are default implementations:
    TransactionFactory creates a new transaction, and NamePasswordResolver creates a Credentials instance based on static user name and password values.


2 data binding through the command object (and execution)
    The command structure consists the following components:
        - CommandFactory (creates a new command instance for each request)
        - Command (is used for data binding, is a container for all the actions, knows how to map action names to new action instances)
        - Action (a single action in the request, there can be many.

    There are a number of basic implementations:

    BasicCommandFactory.
        This implementation takes a List of Class names for all the actions you
        want to use. It uses an instance of the ActionMappingResolver interface, to
        map the action classes to a specific name. the name is important, because it
        is used by the data binding process  ("actions[<actionMapping>][1].number=1266").
        The actions will be processed by the command in the order or the class name list.
        There is an instance for ActionMappingResolver that assumes a naming convention like : my.path.DoThisAction.class.
        It takes the class name of an action, removes the 'Action' bit in the end (if it is there), removes the path element, and turns the result into lower case.

    BasicCommand
        This implementation has a map that has mapping names as keys, and a map as value that has action id's as keys and action instances as values. For every mapping a lazyMap (commons collections).

    Action
        There are a number of action instances available. Common actions are:
        -creating and nodes
        -creating relations
        -deleting nodes.
        -sorting lists (posrel)
        -switching relation (from one node to another)

    For all the node related actions there is an AbstractNodeAction class, that uses the template pattern. It has all the fields you can set on a node (common, date fields, binary fields), and has many protected methods that are called at relevant times and can be overridden by concrete implementations.

3 resolve the return view
    The ReturnViewResolver interface allows for different strategies for creating a return view.
    For the jsp editors there is a ReferrerResolver, that works the following way:
    If there is an error in the resultContianer the request is redirected to an error page. otherwise the referrer header is read from the request. If the request actions created a new node, the parameter 'nodenr' is added to the URL, and the request is redirected (back).
    This works not for Ajax requests though for two reasons:
    - with http XML requests the referrer header is not (always) set.
    - We don't want to parse the referrer page as a response to an Ajax request.
    So for Ajax we have an AjaxResolver implementation, that creates an XML result that contains information about errors and action results and so on (has yet to be developed)

Cache Flush Architecture
------------------------

Overview:
The cache flush architecture is a plugable system that is loosely coupled to the actions. What happens is that the actions that manipulate the cloud can produce cache flush hints. Those are objects that have information about what nodes have been changed and what the change is. These are added to the request, and are not handled by theWizardController . In stead there is a (Spring) interceptor implementation that will use these cache flush hints and a special request parameter (flushname) to flush certain caches.

As of Now the CacheFlushHint knows three types: 'node', 'relation' and 'request'. When a node was created or modified a cacheflush hint of type 'node' will be created. The same applies to relations (when created or removed). a hint of type 'request' is always added when one or more actions were executed, and simply indicates no more than that (I'm notshure how usefull this is). The class also contains information about what node was changed or the source and destination of changed relations.

The flushnames parameter can contain groups of cache names (or identifiers) that are assigned to a names pace (example: 'node:one,two relation:one,three, where node and relation are the names paces and one,two and three identify caches to be flushed).
These names paces will match the cacheflush hint types so that based on certain actions certain caches can be flushed.
Apart from all this there is an extra structure for modifying the cache identifiers in some arbitrary way. This can be handy if your cache names do have some run time determined prefix or suffix.
Oscache is supported by default (only cache group flushing), but it is easy to add support for your own cache.

As with The WizardController there is a system  of inter-operating interfaces and some useful default implementations, that will be discussed separately.

    CacheHandlerInterceptor implements Interceptor (org.springframework.web.servlet). It is an abstract class that through the template mechanism allows specializations to add specific handling instances. A handling is a mapping between acachflush hint type and some flush operation.

    BasicCacheHanderInterceptor is a concrete implementation based on the CacheFlushHint object. it registers a handler for each type supported by CacheFlushHint.
    It is a very simple system, it relies completely on the flushname parameter to have relevant cache names for the cacheflush hint types. Of the available cache flush hint data only it's type is used.
    The actions mapped to the cache flush hint types consist of the following steps:
    1)A CacheNameResolver instance is obtain from the CacheNameResolverFactory (see below)
    2)The resolver is used to obtain the proper cache identifiers
    3)The flushing of the cache is delegated to the CacheWrapper.

    CacheNameResolver
    This interface introduces the notion of formatting the flushname value in such a way that you can group cache names with name spaces. This is implemented in theTokenizerNamespaceResolver. This class implements the tokenization, and you can register any number of Modifier instances with it.
    There is a Factory (TockenizerCacheNameResolverFactory) that will add the name spaces that match the CahceFlushHint types. This factory is used to create a new CacheNameResolver instance for each Handler invocation.

    Modifier
    This is a simple interface that allows you to implement some modification to the cachenames after they are tokenized, and before they are returned. There is, for example, a PrefixPostfix implementation that adds a static prefix and/or post-fix to the names.

    CacheWrapper
    This class accepts some implementation of the CacheWrapper interface.
    There is an oscache wrapper implementation and a dummy implementation (for testing without oscache).

Templates

There is one more aspect of the flushname parameter. Apart from the formatting that is supported by the tokenizerCacheNameResolver there is the notion of templates.
It is common to create cache names with node numbers in them, like  'programs_[nodenr]' (i.e: programs_12344). So if you have an editor that shows a  list with nodes of some type, and each row calls a wizard, you want 'flushname' to contain the node number of that row.
The list:searchrow tag will help you with this. Templates inside the flushname value are resolved and the node number is appended to the template. The template stays in place, because the flushname value is communicated between wizards through the session, so when you come back to the list later you need it again. In this case the previously appended node number will be cleared out of it, and for each row a new value will be created with the node number of that row.

There are two possible template formats:
'pages_[page]'
where the value between [] is the type of the node you want to insert. With a list of nodes of type 'pages', it will create a value like:
'pages_[page:7349]
The node number is appended to the template.
Sometimes you want to reach a parent node of the node in the list, but you don't know it beforehand. An example is when you list all recent news articles, and you want to flush a cache group that is related to a specific category each news article is related to. to do this you can use a template like:
'pages_[page.insrel.categories]
Now the node number will be resolved as the first node of type categories found along the given path, where the page node of the row in the list is the start node. The format is not flexible. it can contain exactly three steps and a role is required. Constrains and sort order are not supported.

Finally the templates are stripped out of the flushname values by the class FlushNameTemplateBean (that is also used in the vpro-wizards tag list:searchrow), which implements the Modifier interface.

